#!/bin/sh
# 15-asus - Battery Plugin for ASUS laptops w/ asus_wmi driver
#
# Copyright (c) 2021 Thomas Koch <linrunner at gmx.net> and others.
# This software is licensed under the GPL v2 or later.

# Needs: tlp-func-base, 34-tlp-func-platform, 35-tlp-func-batt, tlp-func-stat

# shellcheck disable=SC2086

batdrv_init () {
    # detect hardware and initialize driver
    # rc: 0=matching hardware detected/1=not detected/2=no batteries detected
    # retval: $_batdrv_plugin
    #
    # 1. check for native kernel acpi (Linux 4.17 or higher required)
    #    --> retval $_natacpi:
    #       0=thresholds/
    #       32=disabled/
    #       128=no kernel support/
    #       254=ASUS laptop not supported
    #
    # 2. determine method for
    #    reading battery data                   --> retval $_bm_read,
    #    reading/writing charging thresholds    --> retval $_bm_thresh,
    #    reading/writing force discharge        --> retval $_bm_dischg:
    #       none/natacpi
    #
    # 3. define sysfile basename for natacpi
    #    stop threshold                         --> retval $_bn_stop,
    #
    # 4. determine present batteries
    #    list of batteries (space separated)    --> retval $_batteries;
    #
    # 5. define charge threshold defaults
    #    stop threshold                         --> retval $_bt_def_stop;

    _batdrv_plugin="asus"

    # check plugin simulation override and denylist
    if [ -n "$X_BAT_PLUGIN_SIMULATE" ]; then
        if [ "$X_BAT_PLUGIN_SIMULATE" = "$_batdrv_plugin" ]; then
            echo_debug "bat" "batdrv_init.${_batdrv_plugin}.simulate"
        else
            echo_debug "bat" "batdrv_init.${_batdrv_plugin}.simulate_skip"
            return 1
        fi
    elif wordinlist "$_batdrv_plugin" "$X_BAT_PLUGIN_DENYLIST"; then
        echo_debug "bat" "batdrv_init.${_batdrv_plugin}.denylist"
        return 1
    else
        # check if hardware matches
        if ! is_asus; then
            echo_debug "bat" "batdrv_init.${_batdrv_plugin}.no_match"
            return 1
        fi
    fi

    # presume no features at all
    _natacpi=128
    # shellcheck disable=SC2034
    _bm_read="natacpi"
    _bm_thresh="none"
    # shellcheck disable=SC2034
    _bm_dischg="none"
    _bn_stop=""
    _batteries=""
    _bt_def_start=0
    _bt_def_stop=100

    # --- check for native kernel ACPI
    local bd bs
    local done=0
    for bd in "$ACPIBATDIR"/BAT[01T]; do
        if [ "$(read_sysf $bd/present)" = "1" ]; then
            # record detected batteries and directories
            bs=${bd##/*/}
            if [ -n "$_batteries" ]; then
                _batteries="$_batteries $bs"
            else
                _batteries="$bs"
            fi
            # skip natacpi detection for 2nd and subsequent batteries
            [ $done -eq 1 ] && continue

            done=1
            if [ "$NATACPI_ENABLE" = "0" ]; then
                # natacpi disabled in configuration --> skip actual detection
                _natacpi=32
                continue
            fi

            if [ -f $bd/charge_control_end_threshold ]; then
                # sysfile for stop threshold exists
                _bn_stop="charge_control_end_threshold"
                _natacpi=254
            else
                # nothing detected
                _natacpi=254
                continue
            fi

            if readable_sysf $bd/$_bn_stop; then
                # stop threshold is actually readable
                _natacpi=0
                _bm_thresh="natacpi"
            fi
        fi
    done

    echo_debug "bat" "batdrv_init.${_batdrv_plugin}: batteries=$_batteries; natacpi=$_natacpi; thresh=$_bm_thresh; stop=$_bn_stop;"
    return 0
}

batdrv_select_battery () {
    # determine battery sysfiles and tpacpi-bat index
    # $1: BAT0/BAT1/BATT/DEF
    # # rc: 0=bat exists/1=bat non-existent
    # retval: $_bat_str:   BAT0/BAT1/BATT;
    #         $_bd_read:   directory with battery data sysfiles;
    #         $_bf_stop:   sysfile for stop threshold;
    # prerequisite: batdrv_init()

    # defaults
    _bat_str=""   # no bat
    _bd_read=""   # no directory
    _bf_stop=""

    # validate battery param
    local bs
    case $1 in
        DEF) # 1st battery is default
            _bat_str="${_batteries%% *}"
            ;;

        *)
            if wordinlist "$1" "$_batteries"; then
                _bat_str=$1
            else
                # battery not present --> quit
                echo_debug "bat" "batdrv.${_batdrv_plugin}.select_battery($1).not_present"
                return 1
            fi
            ;;
    esac

    # determine natacpi sysfiles
    _bd_read="$ACPIBATDIR/$_bat_str"
    if [ "$_bm_thresh" = "natacpi" ]; then
        _bf_stop="$ACPIBATDIR/$_bat_str/$_bn_stop"
    fi

    echo_debug "bat" "batdrv.${_batdrv_plugin}.select_battery($1): bat_str=$_bat_str; bd_read=$_bd_read; bf_stop=$_bf_stop"
    return 0
}

batdrv_read_threshold () {
    # read and print charge threshold (stop only)
    # $1: error string
    # global param: $_bf_stop
    # out: threshold 0..100/"$2" on error
    # rc: 0=ok/4=read error
    # prerequisite: batdrv_init(), batdrv_select_battery()

    local out="" rc=0

    out="$X_THRESH_SIMULATE_STOP"
    if [ -n "$out" ]; then
        printf "%s" "$out"
        echo_debug "bat" "batdrv.${_batdrv_plugin}.read_threshold($1).simulate: bf_stop=$_bf_stop; out=$out; rc=$rc"
        return 0
    fi

    out=$(read_sysf $_bf_stop "$2") || rc=4

    # "return" threshold
    if [ "$X_THRESH_SIMULATE_READERR" != "1" ]; then
        printf "%s" "$out"
    else
        rc=4
    fi

    echo_debug "bat" "batdrv.${_batdrv_plugin}.read_threshold(stop): bf_stop=$_bf_stop; out=$out; rc=$rc"
    return $rc
}

batdrv_write_thresholds () {
    # write charge thresholds for a battery
    # use pre-determined method and sysfiles from global parms
    # $1: new start threshold -- dummy for api compatibility, must always be 0 or DEF(=0)
    # $2: new stop threshold 1..100/DEF(default)
    # $3: 0=quiet/1=output parameter errors/2=output progress and errors
    # global param: $_bat_str, $_bf_stop
    # rc: 0=ok/
    #     2=threshold out of range or non-numeric/
    #     4=threshold read error/
    #     5=threshold write error
    # prerequisite: batdrv_init(), batdrv_select_battery()
    local new_start=$1
    local new_stop=$2
    local old_stop
    local verb=${3:-0}

    # insert defaults
    [ "$new_start" = "DEF" ] && new_start=$_bt_def_start
    [ "$new_stop" = "DEF" ] && new_stop=$_bt_def_stop

    # --- validate thresholds
    local rc

    # start: ensure 0 (dummy value)
    if [ "$new_start" != "0" ] ; then
        # threshold != 0
        echo_debug "bat" "batdrv.${_batdrv_plugin}.write_thresholds($1, $2, $3).invalid_start: bat=$_bat_str"
        case $verb in
            1) printf "Warning: charge start threshold %s for %s invalid (must always be 0). Battery skipped.\n" "$new_start" $_bat_str 1>&2 ;;
            2) printf "Error: charge start threshold %s for %s invalid (must always be 0). Aborted.\n" "$new_start" $_bat_str 1>&2 ;;
        esac
        return 2
    fi

    # stop: check for 3 digits max, ensure min 1 / max 100
    if ! is_uint "$new_stop" 3 || \
       ! is_within_bounds $new_stop 1 100; then
        # threshold out of range
        echo_debug "bat" "batdrv.${_batdrv_plugin}.write_thresholds($1, $2, $3).invalid_stop: bat=$_bat_str"
        case $verb in
            1) printf "Warning: charge stop threshold %s for %s invalid or out of range (1..100). Battery skipped.\n" "$new_stop" $_bat_str 1>&2 ;;
            2) printf "Error: charge stop threshold %s for %s invalid or out of range (1..100). Aborted.\n" "$new_stop" $_bat_str 1>&2 ;;
        esac
        return 2
    fi

    # read active stop threshold value
    if ! old_stop=$(batdrv_read_threshold); then
        echo_debug "bat" "batdrv.${_batdrv_plugin}.write_thresholds($1, $2, $3).read_error: bat=$_bat_str"
        case $verb in
            1) printf "Warning: could not read current charge stop threshold for %s. Battery skipped.\n" $_bat_str 1>&2 ;;
            2) printf "Error: could not read current charge stop threshold for %s. Aborted.\n" $_bat_str 1>&2 ;;
        esac
        return 4
    fi

    # write new threshold
    if [ "$verb" = "2" ]; then
        printf "Setting temporary charge threshold for %s:\n" "$_bat_str"
    fi

    local rc=0
    if [ "$old_stop" != "$new_stop" ]; then
        # new threshold differs from effective one --> write it
        write_sysf "$new_stop" $_bf_stop || rc=5
        echo_debug "bat" "batdrv.${_batdrv_plugin}.write_thresholds($1, $2, $3).write: bat=$_bat_str; old=$old_stop; new=$new_stop; rc=$rc"
        case $verb in
            2)
                if [ $rc -eq 0 ]; then
                    printf "  stop = %3d\n" $new_stop
                else
                    printf "  stop = %3d (Error: write failed)\n" $new_stop 1>&2
                fi
                ;;
            1)
                if [ $rc -gt 0 ]; then
                    printf "Warning: writing charge stop threshold for %s failed. Battery skipped.\n" $_bat_str 1>&2
                fi
                ;;
        esac
    else
        echo_debug "bat" "batdrv.${_batdrv_plugin}.write_thresholds($1, $2, $3).no_change: bat=$_bat_str; old=$old_stop; new=$new_stop"
        if [ "$verb" = "2" ]; then
                printf "  stop = %3d (no change)\n" $new_stop
        fi
    fi

    return $rc
}

batdrv_chargeonce () {
    # function not implemented for ASUS laptops
    echo_debug "bat" "batdrv.${_batdrv_plugin}.charge_once.not_implemented"
    return 255
}

batdrv_apply_configured_thresholds () {
    # apply configured stop thresholds from configuration to all batteries
    # output parameter errors only

    if batdrv_select_battery BAT0; then
        batdrv_write_thresholds "DEF" "$STOP_CHARGE_THRESH_BAT0" 1; rc=$?
    fi
    if batdrv_select_battery BATT; then
        # BATT uses BAT0 settings
        batdrv_write_thresholds "DEF" "$STOP_CHARGE_THRESH_BAT0" 1; rc=$?
    fi
    if batdrv_select_battery BAT1; then
        batdrv_write_thresholds "DEF" "$STOP_CHARGE_THRESH_BAT1" 1; rc=$?
    fi

    return 0
}

batdrv_read_force_discharge () {
    # function not implemented for ASUS laptops
    echo_debug "bat" "batdrv.${_batdrv_plugin}.read_force_discharge.not_implemented"
    return 255
}

batdrv_write_force_discharge () {
    # function not implemented for ASUS laptops
    echo_debug "bat" "batdrv.${_batdrv_plugin}.write_force_discharge.not_implemented"
    return 255
}

batdrv_cancel_force_discharge () {
    # function not implemented for ASUS laptops
    echo_debug "bat" "batdrv.${_batdrv_plugin}.cancel_force_discharge.not_implemented"
    return 255
}

batdrv_force_discharge_active () {
    # function not implemented for ASUS laptops
    echo_debug "bat" "batdrv.${_batdrv_plugin}.force_discharge_active.not_implemented"
    return 255
}

batdrv_discharge () {
    # function not implemented for ASUS laptops
    echo_debug "bat" "batdrv.${_batdrv_plugin}.discharge.not_implemented"
    return 255
}

batdrv_show_battery_data () {
    # output battery status
    # $1: 1=verbose
    # global param: $_batteries
    # prerequisite: batdrv_init()
    local verbose=${1:-0}

    printf "+++ Battery Wear Control\n"
    printf "Plugin: %s\n" "$_batdrv_plugin"

    if [ "$_bm_thresh" != "none" ]; then
        printf "Supported features: charge threshold\n"
    else
        printf "Supported features: none\n"
    fi

    printf "Driver usage:\n"
    # native kernel ACPI battery API
    case $_natacpi in
        0) printf "* natacpi    = active (charge thresholds)\n" ;;
        32)  printf "* natacpi    = inactive (disabled by configuration)\n" ;;
        128) printf "* natacpi    = inactive (no kernel support)\n" ;;
        254) printf "* natacpi    = inactive (ASUS laptop not supported)\n" ;;
        *)   printf "* natacpi    = unknown status\n" ;;
    esac
    printf "\n"

    # -- show battery data
    local bat
    local bcnt=0
    local ed ef en
    local efsum=0
    local ensum=0

    for bat in $_batteries; do # iterate batteries
        batdrv_select_battery $bat

        printf "+++ Battery Status: %s\n" "$bat"

        printparm "%-59s = ##%s##" $_bd_read/manufacturer
        printparm "%-59s = ##%s##" $_bd_read/model_name

        if cc=$(read_sysval $_bd_read/cycle_count) && [ $cc -gt 0 ]; then
            printf "%-59s = %6d\n" "$_bd_read/cycle_count" "$cc"
        else
            printf "%-59s = (not supported)\n" "$_bd_read/cycle_count"
        fi

        if [ -f $_bd_read/energy_full ]; then
            printparm "%-59s = ##%6d## [mWh]" $_bd_read/energy_full_design "" 000
            printparm "%-59s = ##%6d## [mWh]" $_bd_read/energy_full "" 000
            printparm "%-59s = ##%6d## [mWh]" $_bd_read/energy_now "" 000
            printparm "%-59s = ##%6d## [mW]" $_bd_read/power_now "" 000

            # store values for charge / capacity calculation below
            ed=$(read_sysval $_bd_read/energy_full_design)
            ef=$(read_sysval $_bd_read/energy_full)
            en=$(read_sysval $_bd_read/energy_now)
            efsum=$((efsum + ef))
            ensum=$((ensum + en))

        elif [ -f $_bd_read/charge_full ]; then
            printparm "%-59s = ##%6d## [mAh]" $_bd_read/charge_full_design "" 000
            printparm "%-59s = ##%6d## [mAh]" $_bd_read/charge_full "" 000
            printparm "%-59s = ##%6d## [mAh]" $_bd_read/charge_now "" 000
            printparm "%-59s = ##%6d## [mA]" $_bd_read/current_now "" 000

            # store values for charge / capacity calculation below
            ed=$(read_sysval $_bd_read/charge_full_design)
            ef=$(read_sysval $_bd_read/charge_full)
            en=$(read_sysval $_bd_read/charge_now)
            efsum=$((efsum + ef))
            ensum=$((ensum + en))

        else
            ed=0
            ef=0
            en=0
        fi

        print_batstate $_bd_read/status
        printf "\n"

        if [ $verbose -eq 1 ]; then
            printparm "%-59s = ##%6s## [mV]" $_bd_read/voltage_min_design "" 000
            printparm "%-59s = ##%6s## [mV]" $_bd_read/voltage_now "" 000
            printf "\n"
        fi

        # --- show battery features: thresholds
        local th lf=0
        if [ "$_bm_thresh" = "natacpi" ]; then
            if th=$(batdrv_read_threshold stop "$_bf_stop" ""); then
                printf "%-59s = %6d [%%]\n" "$_bf_stop"  "$th"
            else
                printf "%-59s = %s [%%]\n"  "$_bf_stop"  "(not available)"
            fi
            lf=1
        fi
        [ $lf -gt 0 ] && printf "\n"

        # --- show charge level (SOC) and capacity
        lf=0
        if [ $ef -ne 0 ]; then
            perl -e 'printf ("%-59s = %6.1f [%%]\n", "Charge",   100.0 * '$en' / '$ef');'
            lf=1
        fi
        if [ $ed -ne 0 ]; then
            perl -e 'printf ("%-59s = %6.1f [%%]\n", "Capacity", 100.0 * '$ef' / '$ed');'
            lf=1
        fi
        [ $lf -gt 0 ] && printf "\n"

        bcnt=$((bcnt+1))

    done # for bat

    if [ $bcnt -gt 1 ] && [ $efsum -ne 0 ]; then
        # more than one battery detected --> show charge total
        perl -e 'printf ("%-59s = %6.1f [%%]\n", "+++ Charge total",   100.0 * '$ensum' / '$efsum');'
        printf "\n"
    fi

    return 0
}

batdrv_recommendations () {
     # no recommendations for ASUS laptops
    return 0
}
